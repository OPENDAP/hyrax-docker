#!/bin/bash
set -e

#
# Travis invocation: ./travis/regression_test_script -i "$SNAPSHOT_IMAGE_TAG"
#
HR0="#######################################################################"
HR1="- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
HR2="--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---"
#############################################################################
# loggy()
function loggy(){
    echo  "$@" | awk '{ print "# "$0;}'  >&2
}
prolog="$0() -"
loggy "$HR0"
loggy "$prolog BEGIN"

default_time_out=30
default_image_name="opendap/hyrax:snapshot"
default_endpoint="http://localhost:8080/opendap"

time_out="${default_time_out}"
test_image_name="${default_image_name}"
end_point="${default_endpoint}"
netrc_file=""
tests=""
tests_log_base=

while getopts "ht:i:e:n:l:" OPTION; do
    case $OPTION in
        h)
            echo "-h help -t time_out -i image_name -e end_point_url -n netrc_file test1 test2 ..."
            exit 0
            ;;
        t)
            time_out=$OPTARG
            ;;
        i)
            test_image_name=$OPTARG
            ;;
        e)
            end_point=$OPTARG
            ;;
        l)
            tests_log_base=$OPTARG
            ;;
        n)
            netrc_file="--netrc ${OPTARG}"
            ;;
        *)
            loggy "Incorrect options provided"
            exit 1
            ;;
    esac
done

shift $(($OPTIND - 1))
tests="$@"

loggy "$prolog $HR1"
loggy "$prolog Using the following configuration:"
loggy "$prolog        time_out: ${time_out}"
loggy "$prolog test_image_name: ${test_image_name}"
loggy "$prolog       end_point: ${end_point}"
loggy "$prolog           tests: ${tests}"
loggy "$prolog  tests_log_base: ${tests_log_base}"

#############################################################################
# waitForHyrax()
#
function waitForHyrax() {
    local prolog="waitForHyrax() -"
    local docker_id="$1"
    # Don't fail on errors, they're expected...
    set +e
    local start
    let start=$(date "+%s")
    local done_flag=""
    local curl_response
    while test -z "${done_flag}"; do
        echo -n "." >&2
        curl -s -c cookies -b cookies -n --netrc-file ${netrc_file} -L ${end_point} >/dev/null 2>&1
        status=$?
        # echo "cURL status: ${status}";
        if [ ${status} -eq 0 ]; then
            loggy "$prolog "
            loggy "$prolog Endpoint may have been retrieved. Checking again..."
            # What happens next: We get the response headers "-I" and look
            # for the string "HTTP/" because we know there will be redirects.
            # We use tail to look at the last HTTP/ header and if that status is
            # 200 we're off to the races.
            curl_response=$(curl -s -c cookies -b cookies -n "$netrc_file" -I -L "$end_point")
            loggy "$prolog curl_response: $curl_response"
            echo "$curl_response" | grep "HTTP/" | tail -1 | grep 200 # > /dev/null;
            found=$?
            # echo "cURL found: ${found}";
            if [ ${found} -eq 0 ]; then
                loggy "$prolog The Test Endpoint URL: ${end_point} returned a status of 200"
                done_flag="yup"
            fi
        fi
        let now=$(date "+%s")
        let elapsed=$now-$start
        # echo "elapsed: $elapsed"
        if [ ${elapsed} -gt ${time_out} ]; then
            loggy "$prolog "
            loggy "$prolog ERROR: Hyrax FAILED To Start! Waited for ${elapsed} seconds"
            loggy "$prolog docker logs: "
            loggy "$(docker logs "$docker_id")"
            loggy "$prolog $HR2"
            loggy "$prolog Hyrax failed to arrive...!"
            exit 1
        fi
    done
    loggy "$prolog "
    loggy "$prolog $HR2"
    loggy "$prolog Start-up Docker logs: "
    loggy "$(docker logs "$docker_id")"
    loggy "$prolog $HR2"
    # Now we can fail on errors again.
    set -e
    loggy "$prolog Hyrax has arrived!"
    return 0
}

function clean_and_start(){
    local prolog="clean_and_start_docker() -"
    loggy "$prolog $HR1"
    loggy "$prolog BEGIN"

    local d_id="$1"
    loggy "$prolog       d_id: $d_id"

    local test_image="$2"
    loggy "$prolog test_image: $test_image"

    # Dump all other containers
    containers=$(docker ps -aq)
    if test -n "${containers}"; then
        loggy  "$prolog Removing containers: ${containers}"
        loggy  "$(docker rm -f ${containers})"
    fi

    loggy "$prolog Starting: $d_id"
    container_id=$(docker run -d -h "$d_id" -p 8080:8080 --name="$d_id" "$test_image")
    loggy "$prolog Started container: $container_id"
    loggy "$prolog END"
}



d_id="hyrax"

clean_and_start "$d_id" "$test_image_name"
waitForHyrax "$d_id"

loggy "$HR1"
loggy "$prolog Testing image: ${test_image_name}"
set -x

# If the regression tests fail we want the logs, so don't exit on fail right here
set +e
docker exec -it $d_id /bin/bash -c "cd hyrax_regression_tests; ./testsuite --hyraxurl=\"${end_point}\" ${netrc_file} ${tests};"
test_status=$?
set -e
# http_url https_url stdout testsuite.log
log_file="$tests_log_base.tgz"
loggy "$prolog log_file: $log_file"

ret_dir=$PWD
cd "/tmp"

rt_dir="$tests_log_base"
loggy "$prolog rt_dir: $rt_dir"

loggy "$prolog Creating host directory '$PWD/$rt_dir' for docker run reggression test results."
mkdir -vp "$rt_dir"

for name in testsuite.log testsuite.dir
do
    source_name="$d_id:/hyrax_regression_tests/$name"
    target_name="$rt_dir/$name"
    loggy "$prolog AWS S3: Copying '$source_name' to '$target_name'"
    docker cp "$source_name" "$target_name"
done
loggy "$prolog TarballBeGzipping': $rt_dir)"
tar -cvzf "$log_file" "$rt_dir"
loggy "$prolog log_file: $(ls -l "$log_file")"

cd "$ret_dir"

loggy "$HR1"
loggy "$prolog Checking beslog2json.awk"
loggy "$prolog Python Version: '$(python3 --version)'"
loggy "$prolog Acquiring bes.log from docker image."
docker cp $d_id:/var/log/bes/bes.log .

loggy "$prolog Acquiring beslog2json.py from docker image."
docker cp $d_id:/usr/bin/beslog2json.py $(pwd)/beslog2json.py
ls -l ./beslog2json.py

loggy "$HR2"
loggy "$prolog head -n 20 ./bes.log"
head -n 20 ./bes.log

loggy "$HR2"
loggy "Running beslog2json.py:  bes.log -> bes.json "
cat ./bes.log | python3 ./beslog2json.py --all >./bes.json

loggy "$HR2"
loggy "$prolog head -n 10 ./bes.json"
head -n 10 ./bes.json

loggy "$HR2"
loggy "$prolog tail -n 10 ./bes.json"
tail -n 10 ./bes.json

loggy "$HR1"
loggy "Checking bes.json parsability jq"
jq '.' ./bes.json >/dev/null
loggy "$prolog JQ STATUS: $?"

exit $test_status